<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>KAIRA • Go: Zihin Arenası</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<!-- Google Font -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<!-- Bu dosyanın adı: panel.html -->
<!-- Bu dosya, KAIRA'nın öğrenen yapay zeka oyunu "Go: Zihin Arenası"nın Hata Düzeltmeli Final Sürümünü içerir. -->
<style>
    /* Oyun Alanı Stilleri */
    #go-game-container {
        width: 100%;
        max-width: 1400px; /* Oyun alanının maksimum genişliği */
        margin: auto;
        font-family: 'Space Mono', monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #canvas-container {
        width: 100%;
        aspect-ratio: 1 / 1; /* Kare olmasını sağlar */
        cursor: pointer;
        border-radius: 12px;
        box-shadow: 0 0 25px rgba(79, 70, 229, 0.3);
        position: relative; /* Skorları üzerine konumlandırmak için */
    }
    #game-status {
        min-height: 50px;
        width: 100%;
        padding: 1rem;
        background-color: rgba(17, 24, 39, 0.5);
        border: 1px solid #4f46e5;
        border-radius: 8px;
        margin-top: 1.5rem;
        text-align: center;
        color: #c7d2fe;
        font-size: 1.1rem;
        transition: all 0.3s ease;
    }
    .game-button {
        padding: 0.75rem 1.5rem;
        border-radius: 9999px;
        border: 1px solid #4f46e5;
        background-color: rgba(79, 70, 229, 0.4);
        color: #e0e7ff;
        transition: all 0.3s ease;
        font-size: 1rem;
        cursor: pointer;
        margin-top: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .game-button:hover {
        background-color: #4f46e5;
        transform: scale(1.05);
    }
    .score-display {
        position: absolute;
        top: 1rem;
        padding: 0.5rem 1rem;
        background-color: rgba(10, 10, 10, 0.7);
        border-radius: 8px;
        color: white;
        font-size: 1.2rem;
        pointer-events: none; /* Tıklamayı engellememesi için */
    }
    #user-score {
        left: 1rem;
    }
    #kaira-score {
        right: 1rem;
    }
    /* Kurallar/Skor ayar çubuğu */
    #rules-config {
        width: 100%;
        margin-top: 1rem;
        display: flex;
        gap: 0.75rem;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        color: #e0e7ff;
    }
    #rules-config label { font-size: 0.95rem; color: #c7d2fe; }
    #rules-config select, #rules-config input[type="number"] {
        background: rgba(79,70,229,0.15);
        border: 1px solid #4f46e5;
        color: #e0e7ff;
        border-radius: 8px;
        padding: 0.4rem 0.6rem;
    }
    /* --- Minimal yardımcı sınıflar (Tailwind bağımsız) --- */
    html, body { height: 100%; background: radial-gradient(1200px 600px at 50% 0%, rgba(99,102,241,0.15), transparent 60%) #0b1020; margin:0; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .w-full { width: 100%; }
    .h-full { min-height: 100vh; }
    .p-4 { padding: 1rem; }
    .justify-center { justify-content: center; }
    .space-x-4 { gap: 1rem; }
    @media (min-width: 768px) { .md\:p-8 { padding: 2rem; } }
    .text-slate-100 { color: #f1f5f9; }
    .text-slate-400 { color: #94a3b8; }
    .glow-text { text-shadow: 0 0 12px rgba(99,102,241,0.55); }
    .hidden { display: none; }
    .ai-metrics { margin-top: .5rem; font-size: .9rem; color: #c7d2fe; opacity: .9; text-align: center; }
</style>

</head>
<body>

<div class="w-full h-full flex flex-col p-4 md:p-8">
    <div class="w-full flex justify-end mb-4 flex-shrink-0">
        <button id="panel-close-button" class="text-slate-400 hover:text-white transition-colors">
            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
        </button>
    </div>

    <div class="flex-grow overflow-y-auto text-center flex flex-col">
        <h2 class="text-3xl md:text-4xl font-bold mb-2 text-slate-100 glow-text">Go: Zihin Arenası</h2>
        <p class="text-slate-400 mb-6">KΔIRA'ya karşı oyna. Her hamlen, onun hafızasına bir iz bırakır.</p>
        
        <div id="go-game-container">
            <div id="canvas-container">
                <div id="user-score" class="score-display">Esir: 0</div>
                <div id="kaira-score" class="score-display">Esir: 0</div>
            </div>
            <div id="rules-config">
                <label>Skorlama:
                    <select id="scoring-system">
                        <option value="chinese" selected>Çin (alan + taş)</option>
                        <option value="japanese">Japon (alan + esir)</option>
                    </select>
                </label>
                <label>Komi:
                    <input id="komi-input" type="number" step="0.5" value="7.5" />
                </label>
                <span id="komi-note" style="font-size:0.9rem;opacity:.8">(Beyaz'a eklenir)</span>
            </div>
            <div id="game-status">Oyun başlıyor...</div>
            <div id="ai-metrics" class="ai-metrics">ε: 0.20 • Q-durum sayısı: 0 • Skorlama: Çin • Komi: 7.5 • Tahta: 19x19</div>
            <div class="text-center flex space-x-4 justify-center">
                 <button id="pass-btn" class="game-button">Pas Geç</button>
                 <button id="restart-game-btn" class="game-button">Yeni Oyun</button>
                 <button id="music-toggle-btn" class="game-button">
                    <svg id="music-on-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M7 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1zM11.928 4.072a.5.5 0 00-.578.018L8.99 6.5H7a1 1 0 00-1 1v4a1 1 0 001 1h1.99l2.36 2.41a.5.5 0 00.578.018.5.5 0 00.22-.418V4.5a.5.5 0 00-.22-.428zM14.5 6.5a.5.5 0 01.5.5v5a.5.5 0 01-1 0v-5a.5.5 0 01.5-.5zM17 5.5a.5.5 0 01.5.5v7a.5.5 0 01-1 0v-7a.5.5 0 01.5-.5z"/></svg>
                    <svg id="music-off-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M11.928 4.072a.5.5 0 00-.578.018L8.99 6.5H7a1 1 0 00-1 1v4a1 1 0 001 1h1.99l2.36 2.41a.5.5 0 00.578.018.5.5 0 00.22-.418V4.5a.5.5 0 00-.22-.428zM14.25 7.05a.5.5 0 01.707 0L16.414 8.5l1.457-1.457a.5.5 0 01.707.707L17.121 9.207l1.457 1.457a.5.5 0 01-.707.707L16.414 9.914l-1.457 1.457a.5.5 0 01-.707-.707L15.707 9.207l-1.457-1.457a.5.5 0 010-.707zM7 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1z"/></svg>
                 </button>
            </div>
            <div id="qtools" class="text-center flex space-x-4 justify-center" style="margin-top:0.75rem">
                 <button id="export-q-btn" class="game-button">Q-Tablosunu İndir</button>
                 <button id="import-q-btn" class="game-button">Q-Tablosu Yükle</button>
                 <button id="reset-q-btn" class="game-button" style="background-color:rgba(239,68,68,0.3);border-color:#ef4444">Hafızayı Sıfırla</button>
                 <input id="qfile-input" type="file" accept="application/json" style="display:none">
            </div>
        </div>
    </div>
<audio id="game-music" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" loop></audio>
</div>

<script>
// Bu script sadece bu panel içinde çalışır. Kurallar: intihar yasağı, (süper)ko, çift pasla bitiş.
// Skorlama: Çin (alan + taş) veya Japon (alan + esir) + komi. KAIRA, Q-öğrenme ile hamlelerden öğrenir.
let soundsReady = false;

(async () => {
    const loadScript = (src) => new Promise((resolve, reject) => {
        if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Script load error for ${src}`));
        document.head.appendChild(script);
    });

    try {
        if (typeof THREE === 'undefined') {
            await loadScript("https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js");
        }
    } catch (error) {
        console.error("KRİTİK HATA: Three.js yüklenemedi. Oyun başlatılamıyor.", error);
        const statusElement = document.getElementById('game-status');
        if (statusElement) {
            statusElement.textContent = "Oyunun 3D motoru yüklenemedi. İnternet bağlantınızı kontrol edin.";
            statusElement.style.color = '#ef4444';
        }
        return;
    }

    try {
        if (typeof Tone === 'undefined') {
            await loadScript("https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js");
        }
        soundsReady = true;
    } catch (error) {
        console.warn("Ses kütüphanesi (Tone.js) yüklenemedi. Oyun sessiz modda başlayacak.", error);
        soundsReady = false;
    }
    initGoGame();
})();

function initGoGame() {
    const container = document.getElementById('canvas-container');
    if (!container) return;

    // --- UI referansları
    const statusElement = document.getElementById('game-status');
    const restartBtn = document.getElementById('restart-game-btn');
    const passBtn = document.getElementById('pass-btn');
    const userScoreElement = document.getElementById('user-score');
    const kairaScoreElement = document.getElementById('kaira-score');
    const musicToggleBtn = document.getElementById('music-toggle-btn');
    const musicOnIcon = document.getElementById('music-on-icon');
    const musicOffIcon = document.getElementById('music-off-icon');
    const gameMusic = document.getElementById('game-music');
    const scoringSelect = document.getElementById('scoring-system');
    const komiInput = document.getElementById('komi-input');
    const exportBtn = document.getElementById('export-q-btn');
    const importBtn = document.getElementById('import-q-btn');
    const resetBtn  = document.getElementById('reset-q-btn');
    const qfileInput = document.getElementById('qfile-input');
    const metricsEl = document.getElementById('ai-metrics');

    // Öğrenme/log ucu (opsiyonel)
    const LEARNING_ENDPOINT = 'https://d2d35ee85ddd.ngrok-free.app/log_go_game';

    // --- Kurallar ve Öğrenme Parametreleri
    const BOARD_SIZE = 19; // 19x19 (standart tahta)
    const GRID_UNITS = BOARD_SIZE - 1;
    const RULES = {
        scoring: (scoringSelect?.value || 'chinese'), // 'chinese' | 'japanese'
        komi: parseFloat(komiInput?.value || '7.5'),  // Beyaz'a eklenir
        superko: true                                  // Görülen aynı konuma dönmeyi yasakla (Tromp-Taylor/Chinese tarzı)
    };

    // Q-öğrenme parametreleri
    let qTable = loadQTable();       // { stateKey: { 'x,z': value, 'PASS': value } }
    const alpha = 0.3;               // öğrenme oranı
    const gamma = 0.95;              // iskonto
    let epsilon = 0.20;              // keşif oranı (dinamik ayarlanabilir)
    let episode = [];                // {state, action, reward}

    // --- Oyun durumları
    let scene, camera, renderer, boardPlane, raycaster, mouse, clock;
    let boardState, stones, hoverMarker;
    let currentPlayer, gameOver, gameHistory, lastPass;
    let scores; // esir sayıları: {1:0, 2:0}
    let placeSynth, captureSynth;
    let seenPositions; // Superko için görülen tahtalar (sadece taş dizilimi)

    function setupSounds() {
        if (!soundsReady) return;
        placeSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
        captureSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
    }

    function init() {
        scene = new THREE.Scene();
        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 12, 7);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0);
        container.innerHTML = '';
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 15, 12);
        dirLight.castShadow = true;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createBoard();
        setupSounds();
        startGame();
        animate();

        container.addEventListener('mousemove', onMouseMove, false);
        container.addEventListener('mousedown', onMouseDown, false);
        window.addEventListener('resize', onWindowResize, false);
        restartBtn.addEventListener('click', startGame);
        passBtn.addEventListener('click', onPassTurn);
        musicToggleBtn.addEventListener('click', toggleMusic);
        scoringSelect?.addEventListener('change', () => { RULES.scoring = scoringSelect.value; updateStatus(`Skorlama: ${RULES.scoring.toUpperCase()} (komi ${RULES.komi})`); updateMetrics(); });
        komiInput?.addEventListener('input', () => { RULES.komi = parseFloat(komiInput.value || '7.5'); updateStatus(`Komi ${RULES.komi} olarak ayarlandı`); updateMetrics(); });
        exportBtn?.addEventListener('click', exportQTable);
        importBtn?.addEventListener('click', () => qfileInput?.click());
        qfileInput?.addEventListener('change', importQFile);
        resetBtn?.addEventListener('click', resetQTable);
    }

    function createBoard() {
        const boardGroup = new THREE.Group();
        const boardMaterial = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.8, metalness: 0.2 });

        const mainBoardGeom = new THREE.BoxGeometry(GRID_UNITS, 0.5, GRID_UNITS);
        boardPlane = new THREE.Mesh(mainBoardGeom, boardMaterial);
        boardPlane.receiveShadow = true;
        boardGroup.add(boardPlane);

        const edgeHeight = 0.7;
        const edgeThickness = 0.5;
        const edgeGeomH = new THREE.BoxGeometry(GRID_UNITS + edgeThickness, edgeHeight, edgeThickness);
        const edgeGeomV = new THREE.BoxGeometry(edgeThickness, edgeHeight, GRID_UNITS + edgeThickness * 2);

        const edge1 = new THREE.Mesh(edgeGeomH, boardMaterial); edge1.position.z = (GRID_UNITS + edgeThickness) / 2;
        const edge2 = new THREE.Mesh(edgeGeomH, boardMaterial); edge2.position.z = -(GRID_UNITS + edgeThickness) / 2;
        const edge3 = new THREE.Mesh(edgeGeomV, boardMaterial); edge3.position.x = (GRID_UNITS + edgeThickness) / 2;
        const edge4 = new THREE.Mesh(edgeGeomV, boardMaterial); edge4.position.x = -(GRID_UNITS + edgeThickness) / 2;
        boardGroup.add(edge1, edge2, edge3, edge4);
        scene.add(boardGroup);

        const grid = new THREE.GridHelper(GRID_UNITS, GRID_UNITS, 0x000000, 0x000000);
        grid.position.y = 0.251;
        scene.add(grid);

        const dotGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.02, 16);
        const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(i - GRID_UNITS / 2, 0.26, j - GRID_UNITS / 2);
                scene.add(dot);
            }
        }

        const markerGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25 });
        hoverMarker = new THREE.Mesh(markerGeom, markerMat);
        hoverMarker.visible = false;
        scene.add(hoverMarker);
    }

    function startGame() {
        gameOver = false; lastPass = false; currentPlayer = 1; // 1: Siyah (kullanıcı), 2: Beyaz (KAIRA)
        boardState = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
        gameHistory = []; scores = { 1: 0, 2: 0 }; // esir sayıları
        if (stones) stones.forEach(stone => scene.remove(stone));
        stones = [];
        seenPositions = new Set(); // superko için sıfırla
        seenPositions.add(serializeBoard(boardState));
        updateStatus("Oyun Başladı. Hamle sırası sende (Siyah). Kurallar: intihar yasak, süperko aktif.");
        updateScores();
        updateMetrics();
    }

    function updateStatus(text) { statusElement.textContent = text; }
    function updateScores() {
        userScoreElement.textContent = `Esir: ${scores[1]}`;
        kairaScoreElement.textContent = `Esir: ${scores[2]}`;
    }

    // --- Kurallar yardımcıları ---
    const deltas = [ {dx:0,dy:1}, {dx:0,dy:-1}, {dx:1,dy:0}, {dx:-1,dy:0} ];

    function inBounds(x,z){ return x>=0 && x<BOARD_SIZE && z>=0 && z<BOARD_SIZE; }

    function cloneBoard(b){ return b.map(row => row.slice()); }

    function serializeBoard(b){
        // Sadece taş dizilimi (oyuncu kimliği olmadan) — pozisyonel süperko için yeterli
        let s='';
        for(let i=0;i<BOARD_SIZE;i++) for(let j=0;j<BOARD_SIZE;j++) s+=b[i][j];
        return s;
    }

    function findGroup(startX, startZ, player, b) {
        const q = [ {x:startX, z:startZ} ];
        const visited = new Set([`${startX},${startZ}`]);
        const groupStones = [];
        let libertyCoords = new Set();
        while(q.length){
            const {x,z} = q.shift();
            groupStones.push({x,z});
            for(const n of deltas){
                const nx=x+n.dx, nz=z+n.dy, key=`${nx},${nz}`;
                if(!inBounds(nx,nz)) continue;
                if(b[nx][nz]===0){ libertyCoords.add(key); continue; }
                if(b[nx][nz]===player && !visited.has(key)) { visited.add(key); q.push({x:nx,z:nz}); }
            }
        }
        return { stones: groupStones, liberties: libertyCoords.size };
    }

    function getCapturedStones(x,z,player,b){
        const opp = (player===1?2:1);
        let captured=[];
        for(const n of deltas){
            const nx=x+n.dx, nz=z+n.dy;
            if(inBounds(nx,nz) && b[nx][nz]===opp){
                const grp = findGroup(nx,nz,opp,b);
                if(grp.liberties===0) captured = captured.concat(grp.stones);
            }
        }
        return captured;
    }

    function simulateMove(player,x,z){
        if(!inBounds(x,z) || boardState[x][z]!==0) return { legal:false };
        const b = cloneBoard(boardState);
        b[x][z]=player;
        const captured = getCapturedStones(x,z,player,b);
        // yakalananları sil
        for(const c of captured){ b[c.x][c.z]=0; }
        const grp = findGroup(x,z,player,b);
        if(captured.length===0 && grp.liberties===0){
            // intihar
            return { legal:false, reason:'suicide' };
        }
        // Süperko: aynı taş dizilimine dönmek yasak
        const hash = serializeBoard(b);
        if(RULES.superko && seenPositions.has(hash)){
            return { legal:false, reason:'superko' };
        }
        return { legal:true, tempBoard:b, captured, hash };
    }

    // --- Görsel taş ekleme / kaldırma ---
    function addStoneMesh(x,z,player){
        const stoneGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.15, 32);
        const stoneMaterial = new THREE.MeshStandardMaterial({
            color: (player === 1) ? 0x1a1a1a : 0xf0f0f0,
            roughness: (player === 1) ? 0.4 : 0.2,
            metalness: (player === 1) ? 0.3 : 0.0
        });
        const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
        stone.castShadow = true;
        stone.userData = { x, z };
        const boardX = x - GRID_UNITS / 2;
        const boardZ = z - GRID_UNITS / 2;
        stone.position.set(boardX, 0.325, boardZ);
        scene.add(stone);
        stones.push(stone);
        animateScale(stone, 0.1, 1, 300);
        if(soundsReady && Tone.context.state === 'running') placeSynth.triggerAttackRelease("C4", "8n", Tone.now());
    }

    function removeCapturedMeshes(captured){
        if(!captured || !captured.length) return;
        for(const cap of captured){
            const m = stones.find(s => s.userData.x === cap.x && s.userData.z === cap.z);
            if(m){
                animateScale(m, 1, 0.1, 300, () => scene.remove(m));
                stones = stones.filter(s => s !== m);
            }
        }
        if(soundsReady && Tone.context.state === 'running') captureSynth.triggerAttackRelease(["C3","E3","G3"], "4n", Tone.now());
    }

    function placeStone(x,z, isUser=true){
        const player = currentPlayer;
        const sim = simulateMove(player,x,z);
        if(!sim.legal){
            if(isUser){
                if(sim.reason==='suicide') updateStatus("İntihar hamlesi! Geçersiz.");
                else if(sim.reason==='superko') updateStatus("SÜPERKO ihlali: önceki konum tekrar edilemez.");
                else updateStatus("Geçersiz hamle.");
            }
            return { ok:false, captured:0 };
        }
        // Tahta durumunu uygula
        boardState = sim.tempBoard;
        addStoneMesh(x,z,player);
        removeCapturedMeshes(sim.captured);
        const capturedCount = sim.captured.length;
        scores[player] += capturedCount; // esir sayısı (Japon sayımında kullanılır)
        updateScores();
        updateMetrics();
        seenPositions.add(sim.hash);
        lastPass = false;
        gameHistory.push({ player, x, z, captured: capturedCount });
        endTurn();
        return { ok:true, captured:capturedCount };
    }

    function onPassTurn(){
        if (gameOver || currentPlayer !== 1) return;
        applyPass();
    }

    function applyPass(){
        gameHistory.push({ player: currentPlayer, action: 'pass' });
        if (lastPass) { endGame(); }
        else { lastPass = true; endTurn(); }
    }

    function endTurn(){
        if (gameOver) return;
        currentPlayer = (currentPlayer === 1) ? 2 : 1;
        if (currentPlayer === 1) { updateStatus("Hamle sırası sende (Siyah)."); }
        else {
            const thinkingTexts = ["Hamleni analiz ediyorum...", "Stratejini hesaplıyorum...", "Bir sonraki adımı düşünüyorum..."];
            updateStatus(`KΔIRA düşünüyor: ${thinkingTexts[Math.floor(Math.random() * thinkingTexts.length)]}`);
            setTimeout(kairaTurn, 400);
        }
    }

    function legalMoves(player){
        const list = [];
        for(let i=0;i<BOARD_SIZE;i++) for(let j=0;j<BOARD_SIZE;j++){
            const sim = simulateMove(player,i,j);
            if(sim.legal) list.push({x:i,z:j,captured:sim.captured.length,hash:sim.hash});
        }
        // PASS her zaman yasal — ama tercih sırası Q değeriyle
        list.push({pass:true});
        return list;
    }

    function kairaTurn(){
        if (gameOver) return;
        const player = 2; // KAIRA beyaz
        const state = serializeBoard(boardState) + `|P${player}`;
        const moves = legalMoves(player);
        if(moves.length===0){ applyPass(); return; }

        // Epsilon-greedy seçim
        let action;
        if(Math.random() < epsilon){
            action = moves[Math.floor(Math.random()*moves.length)];
        } else {
            // en yüksek Q değerli hamle
            const qs = qTable[state] || {};
            let bestVal = -Infinity, best = null;
            for(const m of moves){
                const key = m.pass ? 'PASS' : `${m.x},${m.z}`;
                const val = (qs[key] ?? 0);
                if(val > bestVal){ bestVal = val; best = m; }
            }
            action = best || moves[0];
        }

        // Ödül: anlık esir sayısı (yakalanan taş sayısı)
        let reward = 0;
        if(action.pass){
            applyPass();
        } else {
            reward = simulateMove(player, action.x, action.z).captured?.length || 0;
            placeStone(action.x, action.z, false);
        }
        episode.push({ state, action: action.pass ? 'PASS' : `${action.x},${action.z}`, reward });
    }

    function endGame(){
        if (gameOver) return; gameOver = true;
        // Puanları hesapla
        const score = computeFinalScore();
        let winner;
        if (score.blackTotal > score.whiteTotal){ winner='Sen (Siyah)'; updateStatus(`Kazandın! Skor: Siyah ${score.blackTotal.toFixed(1)} - Beyaz ${score.whiteTotal.toFixed(1)}`); }
        else if (score.whiteTotal > score.blackTotal){ winner='KΔIRA (Beyaz)'; updateStatus(`KΔIRA kazandı. Skor: Beyaz ${score.whiteTotal.toFixed(1)} - Siyah ${score.blackTotal.toFixed(1)}`); }
        else { winner='Berabere'; updateStatus(`Berabere. ${score.blackTotal.toFixed(1)} - ${score.whiteTotal.toFixed(1)}`); }
        // Öğrenme: KAIRA perspektifi
        applyQLearning(winner);
        logGameResult(winner, score);
    }

    function computeFinalScore(){
        // Taş sayıları
        let stonesBlack=0, stonesWhite=0;
        for(let i=0;i<BOARD_SIZE;i++) for(let j=0;j<BOARD_SIZE;j++){
            if(boardState[i][j]===1) stonesBlack++; else if(boardState[i][j]===2) stonesWhite++;
        }
        // Territory hesapla (boş bölgelerin sınır renklerine bak)
        const visited = new Set();
        let terrB=0, terrW=0;
        for(let i=0;i<BOARD_SIZE;i++){
            for(let j=0;j<BOARD_SIZE;j++){
                if(boardState[i][j]!==0) continue;
                const key=`${i},${j}`; if(visited.has(key)) continue;
                const q=[{x:i,z:j}], region=[], borders=new Set(); visited.add(key);
                while(q.length){
                    const {x,z}=q.shift(); region.push({x,z});
                    for(const d of deltas){
                        const nx=x+d.dx, nz=z+d.dy, k=`${nx},${nz}`;
                        if(!inBounds(nx,nz)) continue;
                        const v=boardState[nx][nz];
                        if(v===0){ if(!visited.has(k)){ visited.add(k); q.push({x:nx,z:nz}); } }
                        else { borders.add(v); }
                    }
                }
                if(borders.size===1){
                    const owner=[...borders][0];
                    if(owner===1) terrB+=region.length; else if(owner===2) terrW+=region.length;
                }
            }
        }
        const komi = RULES.komi||6.5;
        let blackTotal, whiteTotal;
        if(RULES.scoring==='chinese'){
            blackTotal = stonesBlack + terrB; // Çin: taş + alan
            whiteTotal = stonesWhite + terrW + komi;
        } else { // japanese
            blackTotal = terrB + (scores[1]||0); // Japon: alan + esir
            whiteTotal = terrW + (scores[2]||0) + komi;
        }
        return { stonesBlack, stonesWhite, terrB, terrW, komi, blackTotal, whiteTotal };
    }

    function applyQLearning(winner){
        // KAIRA beyaz (player 2). Ödül: kazanırsa +1, kaybederse -1, berabere 0.
        let terminalReward = 0;
        if(winner==='KΔIRA (Beyaz)') terminalReward = 1; else if(winner==='Sen (Siyah)') terminalReward = -1; else terminalReward = 0;
        // Geriye doğru toplam ödül (return) ile güncelle
        let G = terminalReward;
        for(let t=episode.length-1; t>=0; t--){
            const {state, action, reward} = episode[t];
            G = reward + gamma * G; // anlık ödül + iskonto edilmiş gelecek
            if(!qTable[state]) qTable[state] = {};
            const old = qTable[state][action] ?? 0;
            qTable[state][action] = old + alpha * (G - old);
        }
        saveQTable(qTable);
        // Küçükçe keşif oranını azalt (minimum 0.05)
        epsilon = Math.max(0.05, epsilon * 0.995);
        episode = [];
        updateMetrics();
    }

    async function logGameResult(winner, score) {
        try {
            await fetch(LEARNING_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
                body: JSON.stringify({ winner, history: gameHistory, boardSize: BOARD_SIZE, score, timestamp: new Date().toISOString() })
            });
        } catch (error) { console.error("Oyun sonucu gönderilemedi:", error); }
    }

    function onMouseMove(event) {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
    }

    function onMouseDown(){
        if (currentPlayer !== 1 || gameOver) return;
        if (hoverMarker.visible) {
            const x = Math.round(hoverMarker.position.x + GRID_UNITS / 2);
            const z = Math.round(hoverMarker.position.z + GRID_UNITS / 2);
            placeStone(x, z, true);
        }
    }

    function onWindowResize() {
        if (!container.clientWidth || !container.clientHeight) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animateScale(object, from, to, duration, onComplete) {
        const start = Date.now();
        object.scale.set(from, from, from);
        const update = () => {
            const elapsed = Date.now() - start;
            const progress = Math.min(elapsed / duration, 1);
            const scale = from + (to - from) * progress;
            object.scale.set(scale, scale, scale);
            if (progress < 1) { requestAnimationFrame(update); } else if (onComplete) { onComplete(); }
        };
        update();
    }

    function toggleMusic() {
        if (soundsReady && Tone.context.state !== 'running') { Tone.context.resume(); }
        if (gameMusic.paused) {
            gameMusic.play().catch(e => console.error("Müzik çalınamadı:", e));
            gameMusic.volume = 0.3;
            musicOnIcon.classList.remove('hidden');
            musicOffIcon.classList.add('hidden');
        } else {
            gameMusic.pause();
            musicOnIcon.classList.add('hidden');
            musicOffIcon.classList.remove('hidden');
        }
    }

    function animate(){
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        camera.position.x = Math.sin(elapsedTime * (Math.PI * 2 / 600)) * 10;
        camera.position.z = Math.cos(elapsedTime * (Math.PI * 2 / 600)) * 10;
        camera.lookAt(0, 0, 0);

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(boardPlane);
        if (intersects.length > 0 && !gameOver && currentPlayer === 1) {
            const intersectPoint = intersects[0].point;
            const x = Math.round(intersectPoint.x);
            const z = Math.round(intersectPoint.z);
            const arrayX = x + GRID_UNITS / 2;
            const arrayZ = z + GRID_UNITS / 2;
            if (inBounds(arrayX,arrayZ) && boardState[arrayX][arrayZ] === 0 && simulateMove(1,arrayX,arrayZ).legal) {
                hoverMarker.position.set(x, 0.325, z);
                hoverMarker.visible = true;
            } else { hoverMarker.visible = false; }
        } else { hoverMarker.visible = false; }

        renderer.render(scene, camera);
    }

    // Q-table depolama
    function loadQTable(){ try { return JSON.parse(localStorage.getItem('kaira_go_q')||'{}'); } catch(e){ return {}; } }
    function saveQTable(table){ try { localStorage.setItem('kaira_go_q', JSON.stringify(table)); } catch(e){} }

    // ---- Q-Tablosu araçları ----
    function qStateCount(){ try { return Object.keys(qTable||{}).length; } catch(e){ return 0; } }

    function exportQTable(){
        try {
            const data = JSON.stringify(qTable || {}, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g,'-');
            a.href = url; a.download = `kaira_go_q_${ts}.json`;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
            updateStatus('Q-tablosu indirildi.');
        } catch (e) { console.error(e); updateStatus('Q-tablosu indirilemedi.'); }
    }

    function importQFile(ev){
        const file = ev.target?.files?.[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const obj = JSON.parse(String(reader.result||'{}'));
                if (obj && typeof obj === 'object') {
                    qTable = obj; saveQTable(qTable); updateStatus('Q-tablosu yüklendi.'); updateMetrics();
                } else { updateStatus('Geçersiz Q-tablosu dosyası.'); }
            } catch (e) { console.error(e); updateStatus('Dosya okunamadı / JSON geçersiz.'); }
            qfileInput.value = '';
        };
        reader.readAsText(file);
    }

    function resetQTable(){
        try { localStorage.removeItem('kaira_go_q'); } catch(e){}
        qTable = {}; updateStatus('Hafıza sıfırlandı.'); updateMetrics();
    }

    function updateMetrics(){
        if(!metricsEl) return;
        const eps = (typeof epsilon==='number') ? epsilon.toFixed(2) : '—';
        const scoreName = (RULES.scoring==='japanese' ? 'Japon' : 'Çin');
        const komi = (RULES.komi ?? 7.5).toFixed(1);
        metricsEl.textContent = `ε: ${eps} • Q-durum sayısı: ${qStateCount()} • Skorlama: ${scoreName} • Komi: ${komi} • Tahta: ${BOARD_SIZE}x${BOARD_SIZE}`;
    }

    init();
}
</script>

</body>
</html>
